<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>内存管理-垃圾回收</title>
<script>
//当12~13行代码执行后，
//i是否还在内存中？全局作用域能否访问i？相当于闭包
//j是否还在内存中？
let f;
{
  let i= 1;
  let j= 3;
  f= function (){
    console.log(i);
  }
}
f();

</script>
</head>

<body>
<p>自2012年起，各浏览器(IE8)使用“标记-清除算法”或其改良版来完成程序内存垃圾回收。</p>
<h3>标记-清除算法</h3>
<p>【官方】垃圾回收器将定期从全局对象开始，找所有从全局对象开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象，分别标记为可访问的“对象”和不可访问的“对象”，清除不可访问的“对象”。</p>
<p>【我的理解】垃圾回收器会定期查找全局对象(window，包括其成员)和全局标识符(变量、常量、函数)引用的所有“对象”(数组、函数、自定义对象等)，然后查找这些“对象”引用的所有“对象”，以此类推一直找到末端(最里层)，在查找过程中标记所有可访问的“对象”和所有不可访问的“对象”，最后清除不可访问的对象。</p>
<p>【全局标识符】全局标示符(变量、函数名)都不会被清理，尽量少声明全局标示符。</p>
<p>【函数体内使用外层变量】因为函数调用时才执行函数体，函数内使用的外层作用域变量会被标记为可访问。</p>
</h3>
</body>
</html>
